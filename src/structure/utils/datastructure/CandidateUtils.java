package structure.utils.datastructure;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

import structure.datatypes.AnnotatedDocument;
import structure.datatypes.Mention;
import structure.datatypes.PossibleAssignment;

public class CandidateUtils {

	/**
	 * Iterates through mentions and if there is an intersect between these,
	 * candidates for the respective mentions are merged.
	 * 
	 * @param document         document to be updated
	 * @param docNewCandidates document to be updated from
	 */
	public static void mergeDocumentCandidates(AnnotatedDocument document, AnnotatedDocument docNewCandidates) {
		final Map<String, Mention> mapExistingMentions = new HashMap<>();
		for (Mention existingMention : document.getMentions()) {
			final String mentionStr = MentionUtils.mentionToUniqueStr(existingMention);
			mapExistingMentions.put(mentionStr, existingMention);
		}

		for (Mention newMention : docNewCandidates.getMentions()) {
			final String mentionStr = MentionUtils.mentionToUniqueStr(newMention);
			final Mention existingMention;
			if ((existingMention = mapExistingMentions.get(mentionStr)) != null) {
				// we have found the matching mention -> merge their candidates
				final Collection<PossibleAssignment> existingCandidates = existingMention.getPossibleAssignments();
				final Collection<PossibleAssignment> newCandidates = newMention.getPossibleAssignments();
				final Collection<PossibleAssignment> mergedCandidates = CandidateUtils
						.mergeCandidates(existingCandidates, newCandidates);
				// Update candidate entries for this mention (which exists in both)
				existingMention.updatePossibleAssignments(mergedCandidates);
			} else {
				// Clause will be cleaned by compiler, but here some reasoning behind the
				// behaviour for maintainability purposes
				//
				// Ignored: Candidates generated by component, but no possible mention detected
				// via prior mention detection
				// --> TODO: only for MD+CG combined should it not be ignored
			}
		}
	}

	/**
	 * A simple "add" if candidates are different. Otherwise candidate (specifically
	 * their scores) must be merged. For further merging details check out
	 * {@link #mergeCandidates(PossibleAssignment, PossibleAssignment, boolean)}
	 * 
	 * @param existingCandidates
	 * @param newCandidates
	 * @return
	 */
	public static Collection<PossibleAssignment> mergeCandidates(Collection<PossibleAssignment> existingCandidates,
            Collection<PossibleAssignment> newCandidates) {
        final Collection<PossibleAssignment> retCandidates = new ArrayList<>(
                existingCandidates.size() + newCandidates.size());
        final Map<String, PossibleAssignment> mapAssignments = new HashMap<>();
        for (PossibleAssignment existingCandidate : existingCandidates) {
        	if (existingCandidate == null) continue;
            mapAssignments.put(existingCandidate.getAssignment(), existingCandidate);
            retCandidates.add(existingCandidate);  // Add existing candidates to retCandidates
        }

        for (PossibleAssignment newCandidate : newCandidates) {
            if (newCandidate == null) {
                continue;
            }
            final PossibleAssignment oldCandidate;
            if ((oldCandidate = mapAssignments.get(newCandidate.getAssignment())) == null) {
                // Candidate didn't exist yet!
                retCandidates.add(newCandidate);
            } else {
                // Candidate exists in both old and new lists... -> merge
                final PossibleAssignment mergedCandidate = mergeCandidates(oldCandidate, newCandidate);
                // Check if the merged candidate is already in retCandidates
                boolean isAlreadyPresent = false;
                for (PossibleAssignment candidate : retCandidates) {
                    if (candidate.getAssignment().equals(mergedCandidate.getAssignment())) {
                        isAlreadyPresent = true;
                        break;
                    }
                }
                // Add the merged candidate to retCandidates only if it's not already present
                if (!isAlreadyPresent) {
                    retCandidates.add(mergedCandidate);
                }
            }
        }
        return retCandidates;
    }


	public static PossibleAssignment mergeCandidates(PossibleAssignment oldCandidate, PossibleAssignment newCandidate) {
		return mergeCandidates(oldCandidate, newCandidate, true);
	}

	/**
	 * Merges 2 candidates' scores, creating a copy.
	 * 
	 * @param oldCandidate
	 * @param newCandidate
	 * @param avg_or_max
	 * @return
	 */
	public static PossibleAssignment mergeCandidates(PossibleAssignment oldCandidate, PossibleAssignment newCandidate,
			final boolean avg_or_max) {
		final PossibleAssignment candidate = new PossibleAssignment();
		candidate.setAssignment(oldCandidate.getAssignment());
		final Number mergedScore;
		final double oldScore = oldCandidate.getScore().doubleValue();
		final double newScore = newCandidate.getScore().doubleValue();
		if (avg_or_max) {
			mergedScore = (oldScore + newScore) / 2;
		} else {
			mergedScore = Math.max(oldScore, newScore);
		}
		candidate.setScore(mergedScore);
		return candidate;
	}
}
